<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>20 ab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="assets/css/jquery.toast.min.css">
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
    <div id="app" style="height: 100vh; overflow: hidden;">
        <div v-if="currentPage === 'menu'">
            <div class="center-div">
                <div style="position: relative; left: -50%; top: -50%;">
                    <div class="row justify-content-center">
                        <div class="form-group col-auto">
                            <label for="nicknameInput">Apelido</label>
                            <input type="text" class="form-control" id="nicknameInput" 
                            placeholder="Digite um apelido" v-model="nickname">
                        </div>
                    </div>
                    <div class="row justify-content-center">
                        <button @click="goToPage('game')" type="button" 
                            class="btn btn-secondary col-auto"
                            :disabled="!nickname || nickname.length < 3 || nickname.length > 25">
                            Um jogador
                        </button>
                    </div>
                    <div class="row justify-content-center mt-3">
                        <button @click="goToPage('lobby')" type="button" 
                            class="btn btn-secondary col-auto"
                            :disabled="!nickname || nickname.length < 3 || nickname.length > 25">
                            Multijogador
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="currentPage === 'lobby'">
          <div class="card m-3">
            <div class="card-header">
              Salas
              <div class="row">
                <div class="col font-weight-bold">Nome</div>
                <div class="col font-weight-bold">Número de jogadores</div>
                <div class="col font-weight-bold">Status</div>
                <div class="col font-weight-bold">Ações</div>
              </div>
            </div>
            <div class="card-body py-0 px-3">
              <div v-if="loading" class="row justify-content-center mx-0 py-3">
                <div class="col-auto">
                  <div class="spinner-border text-primary" role="status" style="width: 5rem; height: 5rem;">
                    <span class="sr-only">Carregando...</span>
                  </div>
                </div>
              </div>
              
              <div v-if="!loading && (!rooms || !rooms.length)" class="row bg-light mx-0 py-3">
                <div class="col text-center">
                  Nenhuma sala encontrada
                </div>
              </div>

              <div v-if="!loading && rooms && rooms.length" :style="'overflow: scroll; max-height: ' + (window.innerHeight - 250) + 'px;'">
                <div v-for="(room, index) in rooms" class="row my-3" :key="'room-' + index" :class="{ 'bg-light': index % 2 != 0 }">
                  <div class="col">{{room.name}}</div>
                  <div class="col">{{room.players ? room.players.length : 0}} / 4</div>
                  <div class="col">
                    <span v-if="room.inGame" class="badge badge-success">
                      Em jogo
                    </span>
                    <span v-else class="badge badge-warning">
                      Em espera
                    </span>
                  </div>
                  <div class="col">
                    <button type="button" class="btn btn-primary" @click="enterRoom(room)"
                        :disabled="!room.players || room.players.length >= 4">Entrar</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="card-footer">
              <div class="row justify-content-end">
                <div class="col-auto">
                  <div class="form-group">
                    <input v-model="newRoom.name" type="text" class="form-control" id="newRoomName" placeholder="Insira o nome da sala">
                  </div>
                </div>
                <div class="col-auto">
                  <button v-if="connected" type="button" class="btn btn-success" @click="createRoom()"
                    :disabled="!newRoom || !newRoom.name || newRoom.name.length < 3 || newRoom.name.length > 30">Criar sala</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="center-div">
          <div style="position: relative; left: -50%;">
            <div v-if="currentPage === 'room'">
              <div v-if="currentRoom" class="card m-3">
                <div class="card-header">
                  <div class="row justify-content-between">
                    <div class="col-auto">
                      {{currentRoom.name}}
                    </div>
                    <div class="col-auto">
                      {{currentRoom.players ? currentRoom.players.length : 0}} / 4
                    </div>
                  </div>
                </div>
                <div class="card-body py-0 px-3">
                  <div v-if="currentRoom.players && currentRoom.players.length">
                    <div v-for="(player, index) in currentRoom.players" class="row my-3" :key="'room-' + index" :class="{ 'bg-light': index % 2 != 0 }">
                      <div class="col">{{player.name}}</div>
                    </div>
                  </div>
                </div>
                <div v-if="currentRoom.players && currentRoom.players.length && currentRoom.players[0].id === playerId" 
                    class="card-footer">
                  <div class="row justify-content-end">
                    <div class="col-auto">
                      <button type="button" class="btn btn-primary" @click="startCurrentRoom()">Iniciar partida</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div v-if="currentPage === 'game'">
            <div class="row justify-content-between">
                <div class="col-auto">
                    <span class="m-3 font-weight-bold text-white">Criado por Samuel Alles Remlinger</span>
                </div>
                <div class="col-auto">
                    <div class="mt-2 mr-3">
                        <input type="range" class="form-control-range" v-model="gameSpeed" min="0" max="1000"
                        data-toggle="tooltip" data-placement="bottom" title="Velocidade do Jogo">  
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <div :style="'margin-left: ' + (cardSize.height + 30) + 'px;'">
                        <span v-if="turn" class="font-weight-bold text-white">Turno: {{turn}}<br></span>                
                        <span v-if="turn" class="font-weight-bold text-white">
                            Fase: {{phases[currentPhaseIndex].name}}<br>
                        </span>
                        <span class="font-weight-bold text-white">Nipe trunfo: </span>
                        <img v-if="trumpSuitIndex !== null" :src="'assets/img/suits/' + Object.values(suits)[trumpSuitIndex] + '.png'">
                    </div>
                </div>
                <div class="col">
                    <p class="text-right" :style="'margin-right: ' + (cardSize.height + 30) + 'px;'">
                        <span v-for="(player, index) in players" v-bind:key="'players-points-' + index" 
                            class="font-weight-bold text-white">
                            {{players[index].name}}: {{player.points}}
                            {{' - ' + player.currentTurnPoints}}
                        <br></span>
                    </p>
                </div>
            </div>

            <div v-if="players[3].isPlaying">
                <img v-for="(card, index) in players[3].cardsInHand" v-bind:key="'player3cards-' + index" 
                    src="assets/img/cards/back-hor.jpg" class="player3-card" :width="cardSize.height"
                    :style="'top: ' + ((window.innerHeight / 2) - (((cardSize.width + 4) * players[3].cardsInHand.length) / 2) + ((cardSize.width + 4) * index)) + 'px;'">
            </div>

            <img v-if="gameStarted && !players[3].currentCard && currentPlayerIndex === 3" src="assets/img/arrow.png" class="position-absolute rotate90" 
                :style="'left: ' + (cardSize.height + 30) + 'px; top: ' + ((window.innerHeight / 2) - 29) + 'px;'">

            <img v-if="!winner && players[3].currentCard" :src="'assets/img/cards/' + players[3].currentCard.name + '.png'" 
                class="position-absolute" :height="cardSize.height" :class="{'selected-card': players[3].currentCard.winning}"
                :style="'top: ' + ((window.innerHeight / 2) - (cardSize.height / 2)) + 'px;left: ' + ((window.innerWidth / 2) - (cardSize.width / 2) - cardSize.width - 40) + 'px;'">

            <img v-if="!winner && players[2].currentCard" :src="'assets/img/cards/' + players[2].currentCard.name + '.png'" 
                class="position-absolute" :height="cardSize.height" :class="{'selected-card': players[2].currentCard.winning}"
                :style="'top: ' + ((window.innerHeight / 2) - (cardSize.height / 2) - (cardSize.height / 2) - 10) + 'px;left: ' + ((window.innerWidth / 2) - (cardSize.width / 2)) + 'px;'">

            <div id="player2-cards">
                <div style="position: relative; left: -50%;">
                    <div v-if="players[2].isPlaying" class="row justify-content-center">
                        <img v-for="(card, index) in players[2].cardsInHand" v-bind:key="'player2cards-' +  index" 
                            src="assets/img/cards/back.jpg" class="card-padding-x" :height="cardSize.height">
                    </div>
                    <div v-if="gameStarted && !players[2].currentCard && currentPlayerIndex === 2" class="row justify-content-center" style="margin-top: 20px;">
                        <img src="assets/img/arrow.png" class="rotate180">
                    </div>
                </div>
            </div>

            <img v-if="!winner && players[0].currentCard" :src="'assets/img/cards/' + players[0].currentCard.name + '.png'" 
                class="position-absolute" :height="cardSize.height" :class="{'selected-card': players[0].currentCard.winning}"
                :style="'bottom: ' + ((window.innerHeight / 2) - (cardSize.height / 2) - (cardSize.height / 2) - 10) + 'px;left: ' + ((window.innerWidth / 2) - (cardSize.width / 2)) + 'px;'">

            <div id="player0-cards">
                <div style="position: relative; left: -50%;">
                    <div v-if="gameStarted && !players[0].currentCard && currentPlayerIndex === 0" class="row justify-content-center" style="margin-bottom: 20px;">
                        <img src="assets/img/arrow.png">
                    </div>
                    <div v-if="players[0].isPlaying" class="row justify-content-center">
                        <div v-for="(card, index) in players[0].cardsInHand" v-bind:key="'player0cards-' + index"
                            :class="{'selected-card': card.selected}">
                            <img :height="cardSize.height"
                                :src="'assets/img/cards/' + card.name + '.png'" class="card-padding-x"
                                @click="cardClicked(index)" :class="{'cursor-pointer': isCardClickable}">
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="players[1].isPlaying">
                <img v-for="(card, index) in players[1].cardsInHand" v-bind:key="'player1cards-' + index" 
                    src="assets/img/cards/back-hor.jpg" class="player1-card" :width="cardSize.height"
                    :style="'top: ' + ((window.innerHeight / 2) - (((cardSize.width + 4) * players[1].cardsInHand.length) / 2) + ((cardSize.width + 4) * index)) + 'px;'">
            </div>

            <img v-if="gameStarted && !players[1].currentCard && currentPlayerIndex === 1" src="assets/img/arrow.png" class="position-absolute rotate270" 
                :style="'right: ' + (cardSize.height + 30) + 'px; top: ' + ((window.innerHeight / 2) - 29) + 'px;'">

            <img v-if="!winner && players[1].currentCard" :src="'assets/img/cards/' + players[1].currentCard.name + '.png'" 
                class="position-absolute" :height="cardSize.height" :class="{'selected-card': players[1].currentCard.winning}"
                :style="'top: ' + ((window.innerHeight / 2) - (cardSize.height / 2)) + 'px;right: ' + ((window.innerWidth / 2) - (cardSize.width / 2) - cardSize.width - 40) + 'px;'">

            <div class="center-div">
                <div style="position: relative; left: -50%; top: -50%;">
                    <div v-if="currentTrumpSuitChoicePlayerIndex === 0 && currentPhaseIndex === 1 && trumpSuitIndex === null">
                        <img v-for="(suit, index) in Object.values(suits)" v-bind:key="'suits-' + index"
                            :src="'assets/img/suits/' + suit + '.png'" class="suit-button cursor-pointer"
                            @click="selectTrumpSuit(index)">
                        <div class="row justify-content-center pt-3">
                            <span class="font-weight-bold text-white col-auto">Selecione o nipe trunfo</span>
                        </div>
                    </div>

                    <div v-if="currentPhaseIndex <= 2 && trumpSuitIndex !== null">
                        <div class="row justify-content-center pt-3">
                            <img :src="'assets/img/suits/' + Object.values(suits)[trumpSuitIndex] + '.png'">
                        </div>
                        <span class="font-weight-bold text-white col-auto">Nipe trunfo</span>
                    </div>

                    <div v-if="!exchangeCardsButtonPressed && currentPhaseIndex === 3">
                        <div class="row justify-content-center">
                            <span class="font-weight-bold text-white col-auto">
                                Selecione até 3 cartas para trocar
                            </span>
                        </div>
                        <div class="row justify-content-center pt-3">
                            <button @click="exchangePlayerCards()" type="button" 
                                class="btn btn-secondary col-auto">Continuar</button>
                        </div>
                    </div>

                    <div v-if="!playOrPassButtonPressed && currentPhaseIndex === 4">
                        <div class="row justify-content-center">
                            <span class="font-weight-bold text-white col-auto">
                                Deseja jogar ou passar a rodada?
                            </span>
                        </div>
                        <div class="row justify-content-center pt-3">
                            <button @click="playOrPass(false)" type="button" 
                                class="btn btn-danger col-auto mx-3">Passar</button>
                            <button @click="playOrPass(true)" type="button" 
                                class="btn btn-primary col-auto mx-3">Jogar</button>
                        </div>
                    </div>

                    <div v-if="winner">
                        <span class="font-weight-bold text-white col-auto">
                            {{winner.name}} venceu a partida
                        </span>
                    </div>

                    <div v-if="!gameStarted && (!currentRoom || isMultiplayerGameAndIAmTheRoomMaster)">
                        <div class="row justify-content-center pt-3">
                            <button @click="startGame()" type="button" 
                                class="btn btn-secondary col-auto">Reiniciar partida</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <button v-if="currentPage !== 'menu'" id="back-button" type="button" class="btn btn-secondary" @click="goBack()">
            Voltar
        </button>
    </div>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="./assets/js/jquery.toast.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        var app = new Vue({
            el: '#app',
            data: {
                suits: {
                    hearts: 'h',
                    bells: 'b',
                    leaves: 'l',
                    acorns: 'a',
                },
                ranks: [
                    '7', '8', '9', 'u', 'o', 'k', '10', 'a' 
                ],
                cards: [],
                players: [
                    {
                        id: 0,
                        name: 'Jogador 1',
                        com: false,
                        points: 20,
                        cardsInHand: [],
                        currentCard: null,
                        isPlaying: true,
                        currentTurnPoints: 0,
                        isRoomMaster: false,
                        exchangeCardsSelected: false,
                        playOrPassSelected: false
                    },
                    {
                        id: 1,
                        name: 'Jogador 2',
                        com: true,
                        points: 20,
                        cardsInHand: [],
                        currentCard: null,
                        isPlaying: true,
                        currentTurnPoints: 0,
                        isRoomMaster: false,
                        exchangeCardsSelected: false,
                        playOrPassSelected: false
                    },
                    {
                        id: 2,
                        name: 'Jogador 3',
                        com: true,
                        points: 20,
                        cardsInHand: [],
                        currentCard: null,
                        isPlaying: true,
                        currentTurnPoints: 0,
                        isRoomMaster: false,
                        exchangeCardsSelected: false,
                        playOrPassSelected: false
                    },
                    {
                        id: 3,
                        name: 'Jogador 4',
                        com: true,
                        points: 20,
                        cardsInHand: [],
                        currentCard: null,
                        isPlaying: true,
                        currentTurnPoints: 0,
                        isRoomMaster: false,
                        exchangeCardsSelected: false,
                        playOrPassSelected: false
                    },
                ],
                currentTrick: 0,
                currentTrumpSuitChoicePlayerIndex: 0,
                currentPlayerIndex: 0,
                phases: [
                    {
                        id: 0,
                        name: 'Primeira compra',
                    },
                    {
                        id: 1,
                        name: 'Escolha do nipe trunfo',
                    },
                    {
                        id: 2,
                        name: 'Segunda compra',
                    },
                    {
                        id: 3,
                        name: 'Troca',
                    },
                    {
                        id: 4,
                        name: 'Jogar ou passar',
                    },
                    {
                        id: 5,
                        name: 'Principal',
                    }
                ],
                currentPhaseIndex: 0,
                cardsInDeck: [],
                cardSize: {
                    width: 129 * 0.75,
                    height: 200 * 0.75
                },
                window,
                trumpSuitIndex: null,
                gameSpeed: 500,
                sound: null,
                turn: 0,
                exchangeCardsButtonPressed: false,
                playOrPassButtonPressed: false,
                currentTrickHighestCard: {
                    player: null,
                    card: null
                },
                winners: [],
                lastWinner: null,
                winner: null,
                gameStarted: true,
                pages: [
                    'menu',
                    'game',
                    'lobby',
                    'room'
                ],
                currentPage: 'menu',
                nickname: '',
                socket: null,
                loading: false,
                rooms: [],
                newRoom: {
                  id: null,
                  name: null,
                  players: [],
                  inGame: false
                },
                currentRoom: null,
                playerId: null,
                connected: false,
                socketIOServerURL: 'https://server-20ab.herokuapp.com',
                roomsSearched: false,
                isMultiplayerGameAndIAmTheRoomMaster: false,
                isPlayingCard: false
            },
            mounted() {
                this.window = window;
                this.playerId = this.getUUID();
                this.setCardSize();
                this.setSound();
                this.generateCards();
                
                let nickname = localStorage.getItem('nickname');
                if (nickname && nickname.length) {
                    this.nickname = nickname;
                }
            },
            methods: {
                generateCards() {
                    Object.values(this.suits).forEach(s => {
                        for (let i = 0; i < this.ranks.length; i++) {
                            let r = this.ranks[i];

                            this.cards.push({
                                name: s + r,
                                suit: s,
                                rank: r,
                                power: i + 1
                            });
                        }
                    });
                },
                startGame() {
                  let firstRoomMatch = !this.winner;
                  this.winner = null;
                  this.players.forEach(p => {
                    p.points = 20;
                    p.currentCard = null;
                  });
                  this.reloadPlayers();

                  if (this.isMultiplayerGameAndIAmTheRoomMaster && !firstRoomMatch) {
                    this.sendEvent({
                      channel: this.currentRoom.id,
                      message: {
                        action: 'gameRestart'
                      }
                    });
                  }

                  if (this.currentRoom) {
                    this.socket.on(this.currentRoom.id, data => {
                      this.handleCurrentRoomEvent(data);
                    });

                    if (this.currentRoom && this.currentRoom.players && this.currentRoom.players.length) {
                      let player = this.currentRoom.players.find(p => p.isRoomMaster);

                      this.isMultiplayerGameAndIAmTheRoomMaster = player && player.id === this.playerId;
                    }
                    
                    if (this.isMultiplayerGameAndIAmTheRoomMaster) {
                      this.gameStarted = true;
                      this.currentTrumpSuitChoicePlayerIndex = this.getRandomArbitrary(0, 3);
                      this.currentRoom.inGame = true;

                      if (firstRoomMatch) {
                        this.sendEvent({
                          channel: 'roomUpdate',
                          message: this.currentRoom
                        });
                      }

                      this.players = this.currentRoom.players;

                      if (firstRoomMatch) {
                        this.setComPlayersRandomNames();
                      } else {
                        this.goToNextTurn();
                      }
                    } else {
                      this.goToNextTurn();
                    }
                  } else {
                    this.gameStarted = true;
                    this.currentTrumpSuitChoicePlayerIndex = this.getRandomArbitrary(0, 3);

                    this.setComPlayersRandomNames();
                    this.goToNextTurn();
                  }              
                },
                goToNextTurn() {
                    this.playSound();

                    if (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster) {
                      this.currentTrumpSuitChoicePlayerIndex++;
                      if (this.currentTrumpSuitChoicePlayerIndex > 3) {
                          this.currentTrumpSuitChoicePlayerIndex = 0;
                      }
                      this.currentPlayerIndex = this.currentTrumpSuitChoicePlayerIndex;
                      this.showToast(this.players[this.currentTrumpSuitChoicePlayerIndex].name + ' irá escolher o nipe trunfo');
                    }
                    
                    this.turn++;
                    this.lastWinner = null;
                    this.winners = [];
                    this.exchangeCardsButtonPressed = false;
                    this.playOrPassButtonPressed = false;
                    this.currentPhaseIndex = 0;
                    this.currentTrick = 0;
                    this.trumpSuitIndex = null;
                    this.players.forEach(p => {
                        p.cardsInHand = [];
                        p.currentCard = null;
                        p.isPlaying = true;
                        p.currentTurnPoints = 0;
                        p.exchangeCardsSelected = false;
                        p.playOrPassSelected = false;
                    });
                    
                    if (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster) {
                      this.shuffleDeck();

                      this.sleep().then(() => {
                        this.handleCurrentPhase();
                      });
                    }
                },
                shuffleDeck() {
                    this.cardsInDeck = this.shuffle(JSON.parse(JSON.stringify(this.cards)));
                },
                handleCurrentPhase() {
                    switch (this.currentPhaseIndex) {
                        case 0: {
                          if (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster) {
                            if (this.isMultiplayerGameAndIAmTheRoomMaster) {
                              let tempPlayers = JSON.parse(JSON.stringify(this.players));

                              tempPlayers.forEach(p => {
                                p.cardsInHand.push(this.pickNextCard());
                                p.cardsInHand.push(this.pickNextCard());
                              });

                              this.sendEvent({
                                channel: this.currentRoom.id,
                                message: {
                                  action: 'firstDraw',
                                  data: {
                                    currentTrumpSuitChoicePlayerIndex: this.currentTrumpSuitChoicePlayerIndex,
                                    players: tempPlayers
                                  }
                                }
                              });

                              this.applyFirstDrawTempPlayersCards(tempPlayers);
                            } else {
                              this.sleep().then(() => {
                                this.playSound();

                                for (let i = 0; i < this.players.length; i++) {
                                  let p = this.players[i];
                                  p.cardsInHand[0] = this.pickNextCard();
                                }

                                this.reloadPlayers();
                                this.sleep().then(() => {
                                  this.playSound();

                                  for (let i = 0; i < this.players.length; i++) {
                                    let p = this.players[i];
                                    p.cardsInHand[1] = this.pickNextCard();
                                  }
                                  
                                  this.reloadPlayers();
                                  this.goToNextPhase();
                                });
                              });
                            }
                          }
                            
                          break;
                        }
                        case 1: {
                          if (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster) {
                            if (this.players[this.currentTrumpSuitChoicePlayerIndex].com) {
                                let highestSuitInHand = this.players[this.currentTrumpSuitChoicePlayerIndex].cardsInHand[
                                    this.getBestCardInHandIndex(this.currentTrumpSuitChoicePlayerIndex)
                                ].suit;

                                this.selectTrumpSuit(Object.values(this.suits).findIndex(s => s === highestSuitInHand));
                            }
                          }

                          break;
                        }
                        case 2: {
                          if (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster) {
                            if (this.isMultiplayerGameAndIAmTheRoomMaster) {
                              let tempPlayers = JSON.parse(JSON.stringify(this.players));

                              tempPlayers.forEach(p => {
                                p.cardsInHand.push(this.pickNextCard());
                                p.cardsInHand.push(this.pickNextCard());
                                p.cardsInHand.push(this.pickNextCard());
                              });

                              this.sendEvent({
                                channel: this.currentRoom.id,
                                message: {
                                  action: 'secondDraw',
                                  data: tempPlayers.map(p => {
                                    return {
                                      id: p.id,
                                      cardsInHand: p.cardsInHand
                                    }
                                  })
                                }
                              });

                              this.applySecondDrawTempPlayersCards(tempPlayers);
                            } else {
                              this.sleep().then(() => {
                                this.playSound();

                                for (let i = 0; i < this.players.length; i++) {
                                  let p = this.players[i];
                                  p.cardsInHand[2] = this.pickNextCard();
                                }

                                this.reloadPlayers();
                                this.sleep().then(() => {
                                  this.playSound();

                                  for (let i = 0; i < this.players.length; i++) {
                                    let p = this.players[i];
                                    p.cardsInHand[3] = this.pickNextCard();
                                  }
                                  
                                  this.reloadPlayers();
                                  this.sleep().then(() => {
                                    this.playSound();

                                    for (let i = 0; i < this.players.length; i++) {
                                      let p = this.players[i];
                                      p.cardsInHand[4] = this.pickNextCard();
                                    }

                                    this.reloadPlayers();
                                    this.goToNextPhase();
                                  });
                                });
                              });
                            }
                          }

                          break;
                        }
                        case 3: {
                            this.updateCardPowers();
                            
                            if (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster) {
                              for (let i = 0; i < this.players.length; i++) {
                                  if (this.players[i].com) {
                                      let selectedCards = [];

                                      for (let j = 0; j < this.players[i].cardsInHand.length; j++) {
                                          this.players[i].cardsInHand[i].selected = this.players[i].cardsInHand[i].power <= 4;

                                          if (this.players[i].cardsInHand[i].selected) {
                                              selectedCards.push(i);
                                          }

                                          if (selectedCards.length >= 3) {
                                              break;
                                          }
                                      }

                                      this.players[i].exchangeCardsSelected = true;
                                  }
                              }
                            }

                            break;
                        }
                        case 4: {
                            this.updateCardPowers();

                            if (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster) {
                              for (let i = 0; i < this.players.length; i++) {
                                  if (this.players[i].com) {
                                      let totalPower = 0;
                                      this.players[i].cardsInHand.forEach(c => {
                                          totalPower += c.power;
                                      });

                                      this.players[i].isPlaying = totalPower > 20;
                                      this.players[i].playOrPassSelected = true;
                                      this.showToast(this.players[i].name + ' decidiu ' + (this.players[i].isPlaying ? ' jogar' : ' passar'));

                                      if (!this.players[i].isPlaying) {
                                          this.playSound();
                                      }
                                  }
                              }
                            }
                            
                            break;
                        }
                        case 5: {
                            this.goToNextTrick();

                            break;
                        }
                    }
                },
                applyFirstDrawTempPlayersCards(tempPlayers) {
                  this.sleep().then(() => {
                    this.playSound();

                    for (let i = 0; i < tempPlayers.length; i++) {
                      let tp = tempPlayers[i];
                      let p = this.players[i];
                      p.cardsInHand[0] = tp.cardsInHand[0];
                    }

                    this.reloadPlayers();
                    this.sleep().then(() => {
                        this.playSound();

                        for (let i = 0; i < tempPlayers.length; i++) {
                          let tp = tempPlayers[i];
                          let p = this.players[i];
                          p.cardsInHand[1] = tp.cardsInHand[1];
                        }
                        
                        this.reloadPlayers();                        
                        this.goToNextPhase();
                    });
                  });
                },
                applySecondDrawTempPlayersCards(tempPlayers) {
                  this.sleep().then(() => {
                    this.playSound();

                    for (let i = 0; i < tempPlayers.length; i++) {
                      let tp = tempPlayers[i];
                      let p = this.players[i];
                      p.cardsInHand[2] = tp.cardsInHand[2];
                    }

                    this.reloadPlayers();
                    this.sleep().then(() => {
                      this.playSound();

                      for (let i = 0; i < tempPlayers.length; i++) {
                        let tp = tempPlayers[i];
                        let p = this.players[i];
                        p.cardsInHand[3] = tp.cardsInHand[3];
                      }
                      
                      this.reloadPlayers();                        
                      this.sleep().then(() => {
                        this.playSound();

                        for (let i = 0; i < tempPlayers.length; i++) {
                          let tp = tempPlayers[i];
                          let p = this.players[i];
                          p.cardsInHand[4] = tp.cardsInHand[4];
                        }
                        
                        this.updateCardPowers();
                        this.reloadPlayers();                        
                        this.goToNextPhase();
                      });
                    });
                  });
                },
                pickNextCard() {
                  return this.cardsInDeck.pop();
                },
                goToNextPhase() {
                    this.sleep(2).then(() => {
                        this.currentPhaseIndex++;
                        if (this.currentPhaseIndex > 5) {
                            this.currentPhaseIndex = 0;
                        }
                        
                        this.handleCurrentPhase();
                    });
                },
                selectTrumpSuit(index) {
                    this.playSound();
                    this.trumpSuitIndex = index;
                    this.showToast(
                        this.upperCaseFirstLetter(
                            Object.keys(this.suits)[index]
                        ) + ' foi selecionado como nipe trunfo'
                    );

                    if (this.currentRoom && (
                      this.players[this.currentTrumpSuitChoicePlayerIndex].id === this.playerId
                      || (this.isMultiplayerGameAndIAmTheRoomMaster && this.players[this.currentTrumpSuitChoicePlayerIndex].com)
                    )) {
                      this.sendEvent({
                        channel: this.currentRoom.id,
                        message: {
                          action: 'selectTrumpSuit',
                          data: this.trumpSuitIndex
                        }
                      });
                    }

                    this.goToNextPhase();
                },
                cardClicked(index) {
                    if (this.isCardClickable) {
                        if (this.currentPhaseIndex === 3) { 
                            if (this.players[0].cardsInHand[index].selected 
                                || this.players[0].cardsInHand.filter(c => c.selected).length < 3) {
                                this.playSound();
                                this.players[0].cardsInHand[index].selected = !this.players[0].cardsInHand[index].selected;
                                this.reloadPlayers();
                            }
                        } else {
                            this.playCard(index);
                        }
                    }
                },
                exchangePlayerCards() {
                    this.playSound();
                    this.exchangeCardsButtonPressed = true;
                    this.players[0].exchangeCardsSelected = true;   

                    if (this.currentRoom && !this.isMultiplayerGameAndIAmTheRoomMaster) {
                      this.sendEvent({
                        channel: this.currentRoom.id,
                        message: {
                          action: 'exchangeCardsSelected',
                          data: {
                            playerId: this.playerId,
                            cardsInHand: this.players[0].cardsInHand
                          }
                        }
                      });
                    }

                    this.verifyIfAllPlayersSelectedTheirExchangeCards();
                },
                verifyIfAllPlayersSelectedTheirExchangeCards() {
                  if (!this.currentRoom) {
                    this.applySelectedExchangeCards();
                  } else if (this.isMultiplayerGameAndIAmTheRoomMaster && this.players.findIndex(p => !p.exchangeCardsSelected) === -1) {                 
                    for (let i = 0; i < this.players.length; i++) {
                      let selectedCards = this.players[i].cardsInHand.filter(c => c.selected);

                      if (selectedCards.length) {
                          selectedCards.forEach(sc => {
                              this.players[i].cardsInHand.splice(
                                  this.players[i].cardsInHand.findIndex(c => c.name === sc.name)
                              , 1);
                          });

                          for (let j = 0; j < selectedCards.length; j++) {
                            let card = this.pickNextCard();
                            card.exchanged = true;
                            this.players[i].cardsInHand.push(card);
                          }
                      }
                    }

                    this.sendEvent({
                      channel: this.currentRoom.id,
                      message: {
                        action: 'exchangedCards',
                        data: this.players.map(p => {
                          return {
                            id: p.id,
                            cardsInHand: p.cardsInHand
                          }
                        })
                      }
                    });

                    this.applyMultiplayerSelectedExchangeCards(JSON.parse(JSON.stringify(this.players)));
                  }
                },
                applySelectedExchangeCards() {
                  let exchangedPlayers = [];

                  for (let i = 0; i < this.players.length; i++) {
                      let selectedCards = this.players[i].cardsInHand.filter(c => c.selected);

                      if (selectedCards.length) {
                          this.showToast(this.players[i].name + ' decidiu trocar ' + selectedCards.length + ' cartas');

                          selectedCards.forEach(sc => {
                              this.players[i].cardsInHand.splice(
                                  this.players[i].cardsInHand.findIndex(c => c.name === sc.name)
                              , 1);
                          });

                          this.sleep().then(() => {
                              for (let j = 0; j < selectedCards.length; j++) {
                                  this.sleep(j + 1).then(() => {
                                      this.playSound();
                                      this.players[i].cardsInHand.push(this.pickNextCard());

                                      if (j >= selectedCards.length - 1) {
                                          exchangedPlayers.push(i);
                                      }
                                      
                                      if (exchangedPlayers.length >= 4) {
                                          this.goToNextPhase();
                                      }
                                  });
                              }
                          });
                      } else {
                          this.showToast(this.players[i].name + ' decidiu não trocar nenhuma carta');
                          exchangedPlayers.push(i);

                          if (exchangedPlayers.length >= 4) {
                              this.goToNextPhase();
                          }
                      }
                  }
                },
                applyMultiplayerSelectedExchangeCards(tempPlayers) {
                  let exchangedPlayers = [];

                  for (let i = 0; i < tempPlayers.length; i++) {
                    let notExchangedCards = tempPlayers[i].cardsInHand.filter(c => !c.exchanged);

                    if (notExchangedCards.length < 5) {
                        this.showToast(this.players[i].name + ' decidiu trocar ' + (5 - notExchangedCards.length) + ' cartas');
                        this.players[i].cardsInHand = notExchangedCards;
                        this.reloadPlayers();

                        this.playSound();
                        this.sleep().then(() => {
                            let exchangedCards = tempPlayers[i].cardsInHand.filter(c => c.exchanged);

                            for (let j = 0; j < exchangedCards.length; j++) {
                                this.sleep(j + 1).then(() => {
                                    this.playSound();
                                    let card = exchangedCards[j];
                                    card.exchanged = false;
                                    this.players[i].cardsInHand.push(card);
                                    this.reloadPlayers();

                                    if (j >= exchangedCards.length - 1) {
                                        exchangedPlayers.push(i);
                                    }
                                    
                                    if (exchangedPlayers.length >= 4) {
                                        this.goToNextPhase();
                                    }
                                });
                            }
                        });
                    } else {
                        this.showToast(this.players[i].name + ' decidiu não trocar nenhuma carta');
                        exchangedPlayers.push(i);

                        if (exchangedPlayers.length >= 4) {
                            this.goToNextPhase();
                        }
                    }
                  }
                },
                verifyIfAllPlayersSelectedPlayOrPass() {
                  if (this.isMultiplayerGameAndIAmTheRoomMaster && this.players.findIndex(p => !p.playOrPassSelected) === -1) {
                    this.players.forEach(p => {
                      this.showToast(p.name + ' decidiu ' + (p.isPlaying ? ' jogar' : ' passar'));
                    });

                    this.sendEvent({
                      channel: this.currentRoom.id,
                      message: {
                        action: 'allPlayersSelectedPlayOrPass',
                        data: this.players.map(p => {
                          return {
                            id: p.id,
                            isPlaying: p.isPlaying
                          }
                        })
                      }
                    });

                    this.goToNextPhase();
                  }
                },
                updateCardPowers() {
                    let trumpSuit = Object.values(this.suits)[this.trumpSuitIndex];

                    this.players.forEach(p => {
                        p.cardsInHand.forEach(c => {
                            if (c.suit === trumpSuit && c.power <= 8) {
                                c.power += 8;
                            }
                        });
                    });
                },
                getBestCardInHandIndex(index, basePower) {
                    let highestCardIndex = 0;
                    let lowestCardIndex = 0;

                    for (let i = 1; i < this.players[index].cardsInHand.length; i++) {
                        let c = this.players[index].cardsInHand[i];
                        
                        if (c.power < this.players[index].cardsInHand[highestCardIndex].power) {
                            lowestCardIndex = i;
                        }

                        if (basePower && c.power > basePower && c.power < this.players[index].cardsInHand[highestCardIndex].power) {
                            highestCardIndex = 1;
                        } else if (c.power > this.players[index].cardsInHand[highestCardIndex].power) {
                            highestCardIndex = i;
                        }
                    }

                    if (basePower) {
                        if (this.players[index].cardsInHand[highestCardIndex].power > basePower && this.getRandomArbitrary(1, 2) === 2) {
                            return highestCardIndex;
                        } else {
                            return lowestCardIndex;
                        }
                    }

                    return highestCardIndex;
                },
                playOrPass(value) {
                    this.playSound();
                    this.playOrPassButtonPressed = true;
                    this.players[0].isPlaying = value;
                    this.players[0].playOrPassSelected = true;
                    this.showToast(this.players[0].name + ' decidiu ' + (this.players[0].isPlaying ? ' jogar' : ' passar'));

                    if (this.currentRoom) {
                      if (this.isMultiplayerGameAndIAmTheRoomMaster) {
                        this.verifyIfAllPlayersSelectedPlayOrPass();
                      } else {
                        this.sendEvent({
                          channel: this.currentRoom.id,
                          message: {
                            action: 'playOrPassSelected',
                            data: {
                              playerId: this.playerId,
                              isPlaying: this.players[0].isPlaying
                            }
                          }
                        });
                      }
                    }

                    if (!this.currentRoom) {
                      this.goToNextPhase();
                    }
                },
                goToNextTrick() {
                    this.currentTrick++;

                    if (this.currentTrick > 5) {
                        this.applyPoints();
                    } else {
                        this.currentTrickHighestCard = {
                            player: null, 
                            card: null
                        };
                        this.players.forEach(p => {
                            p.currentCard = null;
                        });
                        this.reloadPlayers();

                        if (this.lastWinner != null) {
                            this.currentPlayerIndex = this.lastWinner;
                        }

                        if (!this.players[this.currentPlayerIndex].isPlaying) {
                            this.passToNextPlayingPlayer();
                        } else {
                            this.comPlayCard();
                        }
                    }
                },
                passToNextPlayingPlayer() {
                    do {
                        this.currentPlayerIndex++;
                        if (this.currentPlayerIndex > 3) {
                            this.currentPlayerIndex = 0;
                        }
                    } while (!this.players[this.currentPlayerIndex].isPlaying);

                    this.sleep(2).then(() => {
                        this.comPlayCard();
                    });
                },
                comPlayCard() {
                    if (this.players[this.currentPlayerIndex].com && (!this.currentRoom || this.isMultiplayerGameAndIAmTheRoomMaster)) {
                        if (this.players[this.currentPlayerIndex].isPlaying) {
                            let basePower = null;
                            if (this.currentTrickHighestCard.card !== null) {
                                basePower = this.players[this.currentTrickHighestCard.player].currentCard.power;
                            }

                            if (basePower) {
                                this.playCard(this.getBestCardInHandIndex(this.currentPlayerIndex, basePower));
                            } else {
                                this.playCard(this.getRandomArbitrary(0, this.players[this.currentPlayerIndex].cardsInHand.length - 1));
                            }
                        } else {
                            this.passToNextPlayingPlayer();
                        }
                    }
                },
                playCard(index, playerIndex) {
                  this.isPlayingCard = true;
                  let ignoreEvent = true;
                  if (playerIndex === undefined) {
                    ignoreEvent = false;
                    playerIndex = this.currentPlayerIndex;
                  }

                  this.playSound();
                  this.players[playerIndex].currentCard = this.players[playerIndex].cardsInHand.splice(index, 1)[0];
                  this.reloadPlayers();
                  
                  if (this.currentRoom && !ignoreEvent) {
                    this.sendEvent({
                      channel: this.currentRoom.id,
                      message: {
                        action: 'playCard',
                        data: {
                          playerId: this.players[playerIndex].id,
                          index: index
                        }
                      }
                    });
                  }
                  
                  let currentCard = this.players[playerIndex].currentCard;

                  this.sleep().then(() => {
                    this.players[playerIndex].currentCard = currentCard;
                    this.reloadPlayers();

                    this.sleep().then(() => {
                      this.players[playerIndex].currentCard = currentCard;

                      if (this.currentTrickHighestCard.card === null 
                          || this.players[playerIndex].currentCard.power > this.players[this.currentTrickHighestCard.player].currentCard.power) {
                          this.currentTrickHighestCard.player = playerIndex;
                          this.currentTrickHighestCard.card = index;
                          this.players.forEach(p => {
                              if (p.currentCard) {
                                  p.currentCard.winning = false;
                              }
                          });
                          this.players[playerIndex].currentCard.winning = true;
                      }
                      
                      this.isPlayingCard = false;
                      this.reloadPlayers();
                      
                      if (this.players.filter(p => p.currentCard !== null).length >= this.players.filter(p => p.isPlaying).length) {
                          this.findWinners();
                      } else {
                          this.passToNextPlayingPlayer();
                      }
                    });
                  });
                },
                findWinners() {
                    this.lastWinner = this.currentTrickHighestCard.player;
                    this.winners = [this.currentTrickHighestCard.player];
                    
                    for (let i = 0; i < this.players.length; i++) {
                        let p = this.players[i];

                        if (p.isPlaying && i !== this.currentTrickHighestCard.player 
                            && this.players[this.currentTrickHighestCard.player].currentCard.power === p.currentCard.power) {
                            this.players[i].currentCard.winning = true;
                            this.winners.push(i);
                        }
                    }
                    
                    if (this.winners.length > 1) {
                        let winnersString = '';
                        for (let i = 0; i < this.winners.length; i++) {
                            let w = this.players[this.winners[i]].name;

                            if (i > 0 && i >= this.winners.length - 1) {
                                winnersString += ' e ';
                            } else if (winnersString.length) {
                                winnersString += ', ';
                            }

                            winnersString += '' + (w + 1);
                        }

                        this.showToast(winnersString + ' venceram a rodada');
                    } else {
                        this.showToast(this.players[this.currentTrickHighestCard.player ].name + ' venceu a rodada');
                    }
                    
                    this.winners.forEach(w => {
                        this.players[w].currentTurnPoints++;
                    });
                    this.sleep(4).then(() => {                      
                        this.goToNextTrick();
                    });
                },
                applyPoints() {
                    let lowestPoint = 0;

                    for (let i = 0; i < this.players.length; i++) {
                        if (this.players[i].isPlaying) {
                            if (this.players[i].currentTurnPoints) {
                                this.showToast(this.players[i].name + ' marcou ' + this.players[i].currentTurnPoints + (this.players[i].currentTurnPoints > 1 ? ' pontos' : ' ponto') + ' neste turno');
                                this.players[i].points -= (this.players[i].currentTurnPoints);
                            } else {
                                this.showToastError(this.players[i].name + ' não marcou nenhum ponto neste turno');
                                if (i === this.currentTrumpSuitChoicePlayerIndex) {
                                    this.players[i].points += 10;
                                } else {
                                    this.players[i].points += 5;
                                }
                            }

                            if (this.players[i].points < lowestPoint) {
                                lowestPoint = this.players[i].points;
                            }
                        }
                    }
                    
                    let gameWinners = this.players.filter(p => p.points === lowestPoint);
                    if (gameWinners.length === 1) {
                        this.showToast(gameWinners[0].name + ' venceu a partida');
                        this.winner = gameWinners[0];
                        this.gameStarted = false;
                    } else {
                        this.goToNextTurn();
                    }
                },
                getRandomArbitrary(min, max) {
                    return Math.floor(Math.random() * (max - min + 1)) + min;
                },
                shuffle(array) {
                    var currentIndex = array.length, temporaryValue, randomIndex;

                    while (0 !== currentIndex) {
                        randomIndex = Math.floor(Math.random() * currentIndex);
                        currentIndex -= 1;
                        temporaryValue = array[currentIndex];
                        array[currentIndex] = array[randomIndex];
                        array[randomIndex] = temporaryValue;
                    }

                    return array;
                },
                showToast(text, bgColor) {
                    let options = {
                        text: text,
                        hideAfter: this.sleepInterval * 10
                    };

                    if (bgColor) {
                        options.bgColor = bgColor;
                    }

                    $.toast(options);
                },
                showToastSuccess(text) {
                    this.showToast(text, 'green');
                },
                showToastError(text) {
                    this.showToast(text, 'red');
                },
                upperCaseFirstLetter(str) {
                    if (str && str.length > 1) {
                        return str.substring(0, 1).toUpperCase() + str.substring(1);
                    }

                    return str;
                },
                sleep(times) {
                    if (times === undefined) {
                        times = 1;
                    }

                    return new Promise(resolve => {
                        setTimeout(resolve, this.sleepInterval * times);
                    });
                },
                setSound() {
                    this.sound = document.createElement("audio");
                    this.sound.src = 'assets/sounds/card.wav';
                    this.sound.setAttribute("preload", "auto");
                    this.sound.setAttribute("controls", "none");
                    this.sound.style.display = "none";
                },
                playSound() {
                    if (this.sound.paused) {
                      this.sound.play();
                    }
                },
                setCardSize() {
                    let oldHeight = this.cardSize.height;
                    this.cardSize.height = (this.window.innerHeight / 4) - (50 / 4);
                    this.cardSize.width = (this.cardSize.height * this.cardSize.width) / oldHeight;
                },
                goToPage(page) {
                    this.playSound();
                    this.currentPage = page;
                    this.handleCurrentPage();
                },
                goBack(ignoreRoomUpdate) {
                    this.playSound();
                    this.roomsSearched = false;

                    if (!ignoreRoomUpdate) {
                      if (this.currentPage === 'room' || (this.currentPage === 'game' && (this.connected || this.roomsSearched))) {
                        if (this.socket && this.currentRoom && this.currentRoom.players && this.currentRoom.players.length) {
                          if (this.currentRoom.players[0].id === this.playerId) {
                            this.sendEvent({
                              channel: 'roomRemoved',
                              message: this.currentRoom
                            });
                          } else {
                            let index = this.currentRoom.players.findIndex(p => p.id === this.playerId);

                            if (index > -1) {
                              this.currentRoom.players.splice(index, 1);

                              this.sendEvent({
                                channel: 'roomUpdate',
                                message: this.currentRoom
                              });
                            }
                          }
                        }
                      }
                    }

                    switch (this.currentPage) {
                      case 'lobby': {
                        this.currentPage = 'menu'; 
                        break; 
                      }
                      case 'room': {
                        this.currentPage = 'lobby'; 
                        this.getRooms();
                        break;
                      }
                      case 'game': {
                        if (this.connected || this.roomsSearched) {
                          this.currentPage = 'lobby';
                          this.getRooms();
                        } else {
                          this.currentPage = 'menu';
                        }

                        break;
                      }
                    }

                    this.handleCurrentPage();
                },
                handleCurrentPage() {
                    switch (this.currentPage) {
                        case 'menu': {
                            this.currentRoom = null;

                            break;
                        }
                        case 'game': {
                            if (!this.currentRoom) {
                              this.players[0].name = this.nickname;
                            }
                            
                            localStorage.setItem('nickname', this.nickname);
                            this.startGame();

                            break;
                        }
                        case 'lobby': {
                          this.isMultiplayerGameAndIAmTheRoomMaster = false;
                          this.rooms = [];
                          this.currentRoom = null;
                          this.getSocket();

                          break;
                        }
                    }
                },
                createRoom() {
                  this.currentRoom = JSON.parse(JSON.stringify(this.newRoom));
                  this.currentRoom.id = this.getUUID();
                  this.currentRoom.players.push({
                    id: this.playerId,
                    name: this.nickname,
                    com: false
                  });
                  this.goToPage('room');
                  this.sendEvent({
                    channel: 'roomUpdate',
                    message: this.currentRoom
                  });
                },
                enterRoom(room) {
                  this.currentRoom = room;
                  let newPlayer = {
                    id: this.playerId,
                    name: this.nickname,
                    com: false
                  };

                  let index = this.currentRoom.players.findIndex(p => p.id === this.playerId);
                  if (index > -1) {
                    this.currentRoom.players[index] = newPlayer;
                  } else {
                    this.currentRoom.players.push(newPlayer);
                  }
                  
                  this.goToPage('room');
                  this.sendEvent({
                    channel: 'roomUpdate',
                    message: this.currentRoom
                  });
                },
                getRooms() {
                  if (!this.roomsSearched) {
                    this.roomsSearched = true;
                    this.sendEvent({
                      channel: 'getRooms',
                      message: {
                        id: this.playerId
                      }
                    });
                  }
                },
                setComPlayersRandomNames() {
                    let numberOfComPlayers = 0;

                    this.players.forEach(p => {
                        if (p.com) {
                            numberOfComPlayers++;
                        }
                    });

                    if (numberOfComPlayers) {
                      axios.get('https://randomuser.me/api/?results=' + numberOfComPlayers + '&nat=DE&inc=name')
                      .then(response => {
                          try {
                            if (response && response.data && response.data.results && response.data.results.length >= numberOfComPlayers) {
                                let j = 0;

                                for (let i = 0; i < this.players.length; i++) {
                                    if (this.players[i].com) {
                                        this.players[i].name = response.data.results[j].name.first;
                                        j++;
                                    }
                                }
                            }
                          } catch (e) {
                            console.error(e);
                          }

                          if (this.currentRoom) {
                            this.goToNextTurn();
                          }
                      })
                      .catch(error => {
                          console.error(error);

                          if (this.currentRoom) {
                            this.goToNextTurn();
                          }
                      });
                    }
                },
                getUUID() {
                  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                  });
                },
                getSocket() {
                  if (!this.socket) {
                    this.loading = true;
                    this.showToast('Conectando ao servidor');
                    this.socket = io(this.socketIOServerURL);

                    this.socket.on('connect', () => {
                      this.connected = true;
                      this.loading = false;
                      this.showToastSuccess('Conectado ao servidor');
                      this.getRooms();
                    });

                    this.socket.on('disconnect', () => {
                      this.loading = false;
                      this.connected = false;
                      console.log('Desconectado do servidor');
                    });

                    this.socket.on(this.playerId, data => {
                      try {
                        if (data.request && data.response) {
                            switch (data.request) {
                                case 'getRooms': {
                                    this.addOrUpdateRoom(data.response);
                                    break;
                                }
                            }
                        }
                      } catch (e) {
                        console.error(e);
                      }
                    });

                    this.socket.on('getRooms', data => {
                      try {
                        if (data.id && this.currentRoom && this.currentRoom.players
                            && this.currentRoom.players.length 
                            && this.currentRoom.players[0].id === this.playerId) {
                            this.sendEvent({
                                channel: data.id,
                                message: {
                                    request: 'getRooms',
                                    response: this.currentRoom
                                }
                            });
                        }
                      } catch (e) {
                        console.error(e);
                      }
                    });
                    
                    this.socket.on('roomUpdate', data => {
                      try {
                        if (data) {
                            if (this.currentPage === 'lobby') {
                                this.addOrUpdateRoom(data);
                            } else if (this.currentPage === 'room' && data.id === this.currentRoom.id) {
                                this.currentRoom = data;

                                if (this.currentRoom.inGame) {
                                  this.showToast(this.currentRoom.players[0].name + " iniciou a partida");
                                  this.goToPage('game');
                                }
                            }
                        }
                      } catch (e) {
                        console.error(e);
                      }
                    });

                    this.socket.on('roomRemoved', data => {
                      try {
                        if (data && data.id) {
                            if (this.currentPage === 'lobby') {
                                let index = this.rooms.findIndex(r => r.id === data.id);
                                if (index > -1) {
                                    this.rooms.splice(index, 1);
                                }
                            } else if (this.currentPage === 'room' && data.id === this.currentRoom.id) {
                                this.goBack(true);
                            }
                        }
                      } catch (e) {
                        console.error(e);
                      }
                    });
                  }

                  return this.socket;
                },
                sendEvent(data) {
                  this.socket.emit('emit-event', JSON.stringify(data));
                },
                addOrUpdateRoom(room) {
                    let index = this.rooms.findIndex(r => r.id === room.id);
                    if (index > -1) {
                        this.rooms[index] = room;
                        this.reloadRooms();
                    } else {
                        this.rooms.push(room);
                    }
                },
                reloadRooms() {
                  let rooms = this.rooms;
                  this.rooms = [];
                  this.rooms = rooms;
                },
                startCurrentRoom() {
                  let i = 1;

                  while (this.currentRoom.players.length < 4) {
                    this.currentRoom.players.push({
                      id: this.getUUID(),
                      name: 'Jogador ' + i,
                      com: true
                    });

                    i++;
                  }

                  this.currentRoom.players.forEach(p => {
                    p.isRoomMaster = false;
                    p.points = 20;
                  });

                  this.currentRoom.players[0].isRoomMaster = true;
                  this.goToPage('game');
                },
                handleCurrentRoomEvent(data) {
                  try {
                    if (this.currentRoom && data && data.action) {
                      switch (data.action) {
                        case 'firstDraw': {
                          if (!this.isMultiplayerGameAndIAmTheRoomMaster) {
                            let ctscpi = data.data.players[data.data.currentTrumpSuitChoicePlayerIndex].id;
                            let tempPlayers = this.convertRemotePlayers(data.data.players);

                            this.currentTrumpSuitChoicePlayerIndex = tempPlayers.findIndex(p => p.id === ctscpi);
                            this.showToast(tempPlayers[this.currentTrumpSuitChoicePlayerIndex].name + ' irá escolher o nipe trunfo');
                            this.currentPlayerIndex = this.currentTrumpSuitChoicePlayerIndex;

                            let players = JSON.parse(JSON.stringify(tempPlayers));
                            players.forEach(p => {
                              p.cardsInHand = [];
                            });
                            this.players = players;

                            this.applyFirstDrawTempPlayersCards(tempPlayers);
                            this.gameStarted = true;
                          }

                          break;
                        }
                        case 'selectTrumpSuit': {
                          if (this.players[this.currentTrumpSuitChoicePlayerIndex].id !== this.playerId && (
                            !this.isMultiplayerGameAndIAmTheRoomMaster || !this.players[this.currentTrumpSuitChoicePlayerIndex].com
                          )) {
                            this.selectTrumpSuit(data.data);
                          }

                          break;
                        }
                        case 'secondDraw': {
                          if (!this.isMultiplayerGameAndIAmTheRoomMaster) {
                            this.applySecondDrawTempPlayersCards(this.convertRemotePlayers(data.data));
                          }

                          break;
                        }
                        case 'exchangeCardsSelected': {
                          if (this.isMultiplayerGameAndIAmTheRoomMaster && data.data.playerId !== this.playerId) {
                            let index = this.players.findIndex(p => p.id === data.data.playerId);
                            this.players[index].cardsInHand = data.data.cardsInHand;
                            this.players[index].exchangeCardsSelected = true;
                            this.verifyIfAllPlayersSelectedTheirExchangeCards();
                          }

                          break;
                        }
                        case 'exchangedCards': {
                          if (!this.isMultiplayerGameAndIAmTheRoomMaster) {
                            this.applyMultiplayerSelectedExchangeCards(this.convertRemotePlayers(data.data));
                          }

                          break;
                        }
                        case 'playOrPassSelected': {
                          if (data.data.playerId !== this.playerId) {
                            let index = this.players.findIndex(p => p.id === data.data.playerId);
                            this.players[index].isPlaying = data.data.isPlaying;
                            this.players[index].playOrPassSelected = true;

                            if (this.isMultiplayerGameAndIAmTheRoomMaster) {
                              this.verifyIfAllPlayersSelectedPlayOrPass();
                            }
                          }

                          break;
                        }
                        case 'allPlayersSelectedPlayOrPass': {
                          if (!this.isMultiplayerGameAndIAmTheRoomMaster) {
                            let tempPlayers = this.convertRemotePlayers(data.data);

                            for (let i = 0; i < this.players.length; i++) {
                              this.players[i].isPlaying = tempPlayers[i].isPlaying;
                              this.showToast(this.players[i].name + ' decidiu ' + (this.players[i].isPlaying ? ' jogar' : ' passar'));
                            }

                            this.goToNextPhase();
                          }

                          break;
                        }
                        case 'playCard': {
                          if (data.data.playerId !== this.playerId) {
                            let index = this.players.findIndex(p => p.id === data.data.playerId);

                            if (!this.isMultiplayerGameAndIAmTheRoomMaster || !this.players[index].com) {
                              if (this.isPlayingCard) {
                                this.sleep(2).then(() => {
                                  this.playCard(data.data.index, index);
                                });
                              } else {
                                this.playCard(data.data.index, index);
                              }
                            }
                          }

                          break;
                        }
                        case 'gameRestart': {
                          if (!this.isMultiplayerGameAndIAmTheRoomMaster) {
                            this.winner = null;
                            this.gameStarted = true;
                            this.players.forEach(p => {
                              p.points = 20;
                            });
                          }

                          break;
                        }
                      }
                    }
                  } catch (e) {
                    console.log(e);
                  }
                },
                convertRemotePlayers(remotePlayers) {
                  let index = remotePlayers.findIndex(p => p.id === this.playerId);

                  while (index !== 0) {
                    let newPlayers = [];

                    newPlayers[0] = remotePlayers[1];
                    newPlayers[1] = remotePlayers[2];
                    newPlayers[2] = remotePlayers[3];
                    newPlayers[3] = remotePlayers[0];

                    remotePlayers = newPlayers;
                    index--;

                    if (index < 0) {
                      index = 3;
                    }
                  }

                  return remotePlayers;
                },
                reloadPlayers() {
                  let players = this.players;
                  this.players = [];
                  this.players = players;
                }
            },
            computed: {
                isCardClickable() {
                  return (
                    this.currentPhaseIndex === 3 && !this.players[0].exchangeCardsSelected
                  ) || (
                    this.currentPhaseIndex === 5 && this.currentPlayerIndex === 0 && this.players[0].currentCard === null
                  );
                },
                sleepInterval() {
                  return 1000 - this.gameSpeed;
                }
            }
        });
    </script>
</body>
</html>